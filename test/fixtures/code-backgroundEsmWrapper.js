const code = "(function () {\n  'use strict';\n\n  /**\n   * Get matches from an object of nested objects\n   *\n   * @export\n   * @template T Type of matches\n   * @param {*} object Parent object to search\n   * @param {(x: any) => boolean} pred A predicate function that will receive each property value of an object\n   * @param {string[]} excludeKeys Exclude a property if the key exactly matches\n   * @returns {T[]} The matched values from the parent object\n   */\n  function getDeepMatches(object, pred, excludeKeys) {\n    const keys = typeof object === 'object' && object ? Object.keys(object) : [];\n\n    return keys.length\n      ? keys\n          .filter((key) => !excludeKeys.includes(key))\n          .reduce((r, key) => {\n            const target = object[key];\n\n            if (target && pred(target)) {\n              return [...r, target]\n            } else {\n              return [...r, ...getDeepMatches(target, pred, excludeKeys)]\n            }\n          }, [] )\n      : []\n  }\n\n  const importPath = /*@__PURE__*/ JSON.parse('%PATH%');\n\n  const events = getDeepMatches(chrome, (x) => typeof x === 'object' && 'addListener' in x, [\n    'webRequest',\n    'extension',\n  ]);\n\n  const triggerEvents = captureEvents(events);\n\n  /** backgroundEsmWrapper */\n  import(importPath).then(async () => {\n    triggerEvents();\n  });\n\n  function captureEvents(events) {\n    const captured = events.map(captureEvent);\n\n    return () => captured.forEach((t) => t())\n\n    function captureEvent(event) {\n      let isCapturePhase = true;\n\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const callbacks = new Map();\n      const eventArgs = new Set();\n\n      // This is the only listener for the native event\n      event.addListener(handleEvent);\n\n      function handleEvent(...args) {\n        if (isCapturePhase) {\n          // This is before dynamic import completes\n          eventArgs.add(args);\n\n          if (typeof args[2] === 'function') {\n            // During capture phase all messages are async\n            return true\n          } else {\n            // Sync messages or some other event\n            return false\n          }\n        } else {\n          // The callbacks determine the listener return value\n          return callListeners(...args)\n        }\n      }\n\n      // Called when dynamic import is complete\n      //  and when subsequent events fire\n      function callListeners(...args) {\n        let isAsyncCallback = false;\n        callbacks.forEach((options, cb) => {\n          // A callback error should not affect the other callbacks\n          try {\n            isAsyncCallback = cb(...args) || isAsyncCallback;\n          } catch (error) {\n            console.error(error);\n          }\n        });\n\n        if (!isAsyncCallback && typeof args[2] === 'function') {\n          // We made this an async message callback during capture phase\n          //   when the function handleEvent returned true\n          //   so we are responsible to call sendResponse\n          // If the callbacks are sync message callbacks\n          //   the sendMessage callback on the other side\n          //   resolves with no arguments (this is the same behavior)\n          args[2]();\n        }\n\n        // Support events after import is complete\n        return isAsyncCallback\n      }\n\n      // This function will trigger this Event with our stored args\n      function triggerEvents() {\n        // Fire each event for this Event\n        eventArgs.forEach((args) => {\n          callListeners(...args);\n        });\n\n        // Dynamic import is complete\n        isCapturePhase = false;\n        // Don't need these anymore\n        eventArgs.clear();\n      }\n\n      // All future listeners are handled by our code\n      event.addListener = function addListener(cb, ...options) {\n        callbacks.set(cb, options);\n      };\n\n      event.hasListeners = function hasListeners() {\n        return callbacks.size > 0\n      };\n\n      event.hasListener = function hasListener(cb) {\n        return callbacks.has(cb)\n      };\n\n      event.removeListener = function removeListener(cb) {\n        callbacks.delete(cb);\n      };\n\n      event.__isCapturedEvent = true;\n\n      return triggerEvents\n    }\n  }\n\n}());\n";

export { code };
